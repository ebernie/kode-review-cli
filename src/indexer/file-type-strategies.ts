/**
 * File-type specific retrieval strategies for optimized context retrieval.
 *
 * Each strategy defines:
 * - Priority patterns to search for (e.g., type definitions, base classes)
 * - Query extraction patterns specific to the language
 * - File patterns to include in related context
 */

import type { WeightedCodeChunk } from './types.js'
import type { IndexerClient } from './client.js'
import { logger } from '../utils/logger.js'

/**
 * Supported file types for specialized retrieval strategies.
 */
export type FileTypeStrategy =
  | 'typescript'
  | 'javascript'
  | 'python'
  | 'go'
  | 'css'
  | 'scss'
  | 'rust'
  | 'java'
  | 'generic'

/**
 * Configuration for a file-type specific retrieval strategy.
 */
export interface FileTypeStrategyConfig {
  /** File extensions this strategy applies to */
  extensions: string[]

  /** Priority patterns to search for (e.g., type definitions, interfaces) */
  priorityPatterns: PriorityPattern[]

  /** Query extraction patterns specific to this file type */
  queryPatterns: QueryPattern[]

  /** Related file patterns to automatically include */
  relatedFilePatterns: RelatedFilePattern[]

  /** Weight multiplier for priority matches (default: 1.5) */
  priorityWeight: number

  /** Whether to search for type/interface definitions automatically */
  searchTypeDefinitions: boolean

  /** Whether to search for base classes/parent classes */
  searchBaseClasses: boolean

  /** Whether to search for imported modules */
  searchImportedModules: boolean
}

/**
 * A pattern for extracting priority context (e.g., type definitions).
 */
export interface PriorityPattern {
  /** Name of the pattern for logging */
  name: string

  /** Regex pattern to match in the code */
  pattern: RegExp

  /** Query template to generate search query. Use $1, $2, etc. for capture groups */
  queryTemplate: string

  /** Weight multiplier for matches from this pattern */
  weight: number
}

/**
 * A pattern for extracting queries from code.
 */
export interface QueryPattern {
  /** Name of the pattern for logging */
  name: string

  /** Regex pattern to match */
  pattern: RegExp

  /** Capture group index to extract (1-based) */
  captureGroup: number
}

/**
 * A pattern for finding related files.
 */
export interface RelatedFilePattern {
  /** Name of the pattern for logging */
  name: string

  /** Transform source filename to related filename */
  transform: (filename: string) => string[]
}

/**
 * Result of applying a file-type strategy.
 */
export interface StrategyResult {
  /** Additional queries generated by the strategy */
  additionalQueries: string[]

  /** Priority chunk IDs that should receive weight boost */
  priorityChunkIds: Set<string>

  /** Related files that were searched */
  relatedFilesSearched: string[]
}

// ============================================================================
// TypeScript/JavaScript Strategy
// ============================================================================

const typescriptPriorityPatterns: PriorityPattern[] = [
  // Type definitions and interfaces
  {
    name: 'type-annotation',
    pattern: /:\s*(\w+)(?:<[^>]+>)?(?:\s*[=;,)\]}|&]|$)/g,
    queryTemplate: 'interface $1',
    weight: 1.5,
  },
  {
    name: 'extends-clause',
    pattern: /extends\s+(\w+)(?:<[^>]+>)?/g,
    queryTemplate: 'class $1',
    weight: 1.6,
  },
  {
    name: 'implements-clause',
    pattern: /implements\s+([\w,\s]+)/g,
    queryTemplate: 'interface $1',
    weight: 1.6,
  },
  // Generic type parameters
  {
    name: 'generic-type',
    pattern: /<(\w+)(?:\s+extends\s+\w+)?>/g,
    queryTemplate: 'type $1',
    weight: 1.3,
  },
  // Import statements - find module definitions
  {
    name: 'named-import',
    pattern: /import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]/g,
    queryTemplate: '$1 $2',
    weight: 1.4,
  },
  {
    name: 'default-import',
    pattern: /import\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g,
    queryTemplate: '$1',
    weight: 1.4,
  },
]

const typescriptQueryPatterns: QueryPattern[] = [
  { name: 'interface-name', pattern: /interface\s+(\w+)/g, captureGroup: 1 },
  { name: 'type-alias', pattern: /type\s+(\w+)\s*[=<]/g, captureGroup: 1 },
  { name: 'class-name', pattern: /class\s+(\w+)/g, captureGroup: 1 },
  { name: 'function-name', pattern: /function\s+(\w+)/g, captureGroup: 1 },
  { name: 'const-function', pattern: /const\s+(\w+)\s*=\s*(?:async\s*)?\(/g, captureGroup: 1 },
  { name: 'method-name', pattern: /(?:async\s+)?(\w+)\s*\([^)]*\)\s*(?::\s*\w+)?\s*\{/g, captureGroup: 1 },
]

const typescriptRelatedFilePatterns: RelatedFilePattern[] = [
  {
    name: 'type-definitions',
    transform: (filename) => {
      const base = filename.replace(/\.(ts|tsx|js|jsx)$/, '')
      return [
        `${base}.d.ts`,
        `${base}.types.ts`,
        `${base}/types.ts`,
        `types/${filename.split('/').pop()?.replace(/\.(ts|tsx|js|jsx)$/, '.ts')}`,
      ].filter(Boolean) as string[]
    },
  },
  {
    name: 'index-exports',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      return dir ? [`${dir}/index.ts`, `${dir}/index.tsx`] : ['index.ts', 'index.tsx']
    },
  },
]

export const typescriptStrategy: FileTypeStrategyConfig = {
  extensions: ['.ts', '.tsx'],
  priorityPatterns: typescriptPriorityPatterns,
  queryPatterns: typescriptQueryPatterns,
  relatedFilePatterns: typescriptRelatedFilePatterns,
  priorityWeight: 1.5,
  searchTypeDefinitions: true,
  searchBaseClasses: true,
  searchImportedModules: true,
}

export const javascriptStrategy: FileTypeStrategyConfig = {
  extensions: ['.js', '.jsx', '.mjs', '.cjs'],
  priorityPatterns: typescriptPriorityPatterns.filter(p => !p.name.includes('type')),
  queryPatterns: typescriptQueryPatterns.filter(p => !p.name.includes('type') && !p.name.includes('interface')),
  relatedFilePatterns: [
    {
      name: 'index-exports',
      transform: (filename) => {
        const dir = filename.split('/').slice(0, -1).join('/')
        return dir ? [`${dir}/index.js`, `${dir}/index.mjs`] : ['index.js', 'index.mjs']
      },
    },
  ],
  priorityWeight: 1.4,
  searchTypeDefinitions: false,
  searchBaseClasses: true,
  searchImportedModules: true,
}

// ============================================================================
// Python Strategy
// ============================================================================

const pythonPriorityPatterns: PriorityPattern[] = [
  // Base class inheritance
  {
    name: 'class-inheritance',
    pattern: /class\s+\w+\s*\(([^)]+)\)/g,
    queryTemplate: 'class $1',
    weight: 1.6,
  },
  // Decorator usage
  {
    name: 'decorator',
    pattern: /@(\w+)(?:\([^)]*\))?/g,
    queryTemplate: 'def $1',
    weight: 1.5,
  },
  // Type hints for return types and parameters
  {
    name: 'type-hint-return',
    pattern: /->\s*(\w+)(?:\[[^\]]+\])?/g,
    queryTemplate: 'class $1',
    weight: 1.4,
  },
  {
    name: 'type-hint-param',
    pattern: /:\s*(\w+)(?:\[[^\]]+\])?\s*[=,)]/g,
    queryTemplate: 'class $1',
    weight: 1.4,
  },
  // Import statements
  {
    name: 'from-import',
    pattern: /from\s+([\w.]+)\s+import\s+(.+)/g,
    queryTemplate: '$2',
    weight: 1.4,
  },
]

const pythonQueryPatterns: QueryPattern[] = [
  { name: 'class-name', pattern: /class\s+(\w+)/g, captureGroup: 1 },
  { name: 'function-name', pattern: /def\s+(\w+)/g, captureGroup: 1 },
  { name: 'async-function', pattern: /async\s+def\s+(\w+)/g, captureGroup: 1 },
  { name: 'decorator-name', pattern: /@(\w+)/g, captureGroup: 1 },
  { name: 'imported-name', pattern: /from\s+[\w.]+\s+import\s+(\w+)/g, captureGroup: 1 },
]

const pythonRelatedFilePatterns: RelatedFilePattern[] = [
  {
    name: '__init__',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      return dir ? [`${dir}/__init__.py`] : ['__init__.py']
    },
  },
  {
    name: 'base-module',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      return dir ? [`${dir}/base.py`, `${dir}/abc.py`, `${dir}/interfaces.py`] : []
    },
  },
  {
    name: 'conftest',
    transform: (filename) => {
      const parts = filename.split('/')
      const results: string[] = []
      for (let i = parts.length - 1; i >= 0; i--) {
        const dir = parts.slice(0, i).join('/')
        results.push(dir ? `${dir}/conftest.py` : 'conftest.py')
      }
      return results
    },
  },
]

export const pythonStrategy: FileTypeStrategyConfig = {
  extensions: ['.py'],
  priorityPatterns: pythonPriorityPatterns,
  queryPatterns: pythonQueryPatterns,
  relatedFilePatterns: pythonRelatedFilePatterns,
  priorityWeight: 1.5,
  searchTypeDefinitions: false, // Python doesn't have separate type definition files
  searchBaseClasses: true,
  searchImportedModules: true,
}

// ============================================================================
// Go Strategy
// ============================================================================

const goPriorityPatterns: PriorityPattern[] = [
  // Interface implementation (struct implementing interface)
  {
    name: 'interface-type',
    pattern: /type\s+(\w+)\s+interface/g,
    queryTemplate: 'interface $1',
    weight: 1.6,
  },
  // Struct embedding
  {
    name: 'struct-embedding',
    pattern: /type\s+\w+\s+struct\s*\{[^}]*\n\s*(\w+)\s*\n/g,
    queryTemplate: 'type $1',
    weight: 1.5,
  },
  // Method receiver type
  {
    name: 'method-receiver',
    pattern: /func\s*\(\s*\w+\s+\*?(\w+)\s*\)/g,
    queryTemplate: 'type $1',
    weight: 1.5,
  },
  // Import statements
  {
    name: 'import-path',
    pattern: /import\s+(?:\w+\s+)?"([^"]+)"/g,
    queryTemplate: '$1',
    weight: 1.3,
  },
]

const goQueryPatterns: QueryPattern[] = [
  { name: 'func-name', pattern: /func\s+(?:\([^)]+\)\s*)?(\w+)/g, captureGroup: 1 },
  { name: 'type-name', pattern: /type\s+(\w+)\s+(?:struct|interface)/g, captureGroup: 1 },
  { name: 'const-name', pattern: /const\s+(\w+)/g, captureGroup: 1 },
  { name: 'var-name', pattern: /var\s+(\w+)/g, captureGroup: 1 },
]

const goRelatedFilePatterns: RelatedFilePattern[] = [
  {
    name: 'doc-file',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      return dir ? [`${dir}/doc.go`] : ['doc.go']
    },
  },
  {
    name: 'interface-file',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      return dir
        ? [`${dir}/interfaces.go`, `${dir}/types.go`, `${dir}/contract.go`]
        : ['interfaces.go', 'types.go', 'contract.go']
    },
  },
]

export const goStrategy: FileTypeStrategyConfig = {
  extensions: ['.go'],
  priorityPatterns: goPriorityPatterns,
  queryPatterns: goQueryPatterns,
  relatedFilePatterns: goRelatedFilePatterns,
  priorityWeight: 1.5,
  searchTypeDefinitions: false, // Go doesn't have separate type files
  searchBaseClasses: false, // Go uses composition, not inheritance
  searchImportedModules: true,
}

// ============================================================================
// CSS/SCSS Strategy
// ============================================================================

const cssPriorityPatterns: PriorityPattern[] = [
  // Variable usage
  {
    name: 'css-variable',
    pattern: /var\(--([a-zA-Z0-9-]+)\)/g,
    queryTemplate: '--$1',
    weight: 1.6,
  },
  // Class reference (in component context)
  {
    name: 'class-selector',
    pattern: /\.([a-zA-Z][a-zA-Z0-9_-]+)/g,
    queryTemplate: '.$1',
    weight: 1.3,
  },
]

const scssPriorityPatterns: PriorityPattern[] = [
  ...cssPriorityPatterns,
  // SCSS variable usage
  {
    name: 'scss-variable',
    pattern: /\$([a-zA-Z][a-zA-Z0-9_-]+)/g,
    queryTemplate: '$$$1', // Escape $ for search
    weight: 1.6,
  },
  // Mixin include
  {
    name: 'mixin-include',
    pattern: /@include\s+([a-zA-Z][a-zA-Z0-9_-]+)/g,
    queryTemplate: '@mixin $1',
    weight: 1.7,
  },
  // Extend
  {
    name: 'extend',
    pattern: /@extend\s+([.%][a-zA-Z][a-zA-Z0-9_-]+)/g,
    queryTemplate: '$1',
    weight: 1.6,
  },
]

const cssQueryPatterns: QueryPattern[] = [
  { name: 'class-selector', pattern: /\.([a-zA-Z][a-zA-Z0-9_-]+)/g, captureGroup: 1 },
  { name: 'id-selector', pattern: /#([a-zA-Z][a-zA-Z0-9_-]+)/g, captureGroup: 1 },
  { name: 'css-variable', pattern: /--([a-zA-Z][a-zA-Z0-9_-]+)/g, captureGroup: 1 },
]

const scssQueryPatterns: QueryPattern[] = [
  ...cssQueryPatterns,
  { name: 'scss-variable', pattern: /\$([a-zA-Z][a-zA-Z0-9_-]+)/g, captureGroup: 1 },
  { name: 'mixin-name', pattern: /@mixin\s+([a-zA-Z][a-zA-Z0-9_-]+)/g, captureGroup: 1 },
  { name: 'function-name', pattern: /@function\s+([a-zA-Z][a-zA-Z0-9_-]+)/g, captureGroup: 1 },
]

const cssRelatedFilePatterns: RelatedFilePattern[] = [
  {
    name: 'variables-file',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      const ext = filename.endsWith('.scss') ? '.scss' : '.css'
      return dir
        ? [`${dir}/_variables${ext}`, `${dir}/variables${ext}`, `${dir}/_vars${ext}`]
        : [`_variables${ext}`, `variables${ext}`]
    },
  },
  {
    name: 'mixins-file',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      return dir
        ? [`${dir}/_mixins.scss`, `${dir}/mixins.scss`]
        : ['_mixins.scss', 'mixins.scss']
    },
  },
  {
    name: 'base-styles',
    transform: (filename) => {
      const dir = filename.split('/').slice(0, -1).join('/')
      const ext = filename.endsWith('.scss') ? '.scss' : '.css'
      return dir
        ? [`${dir}/_base${ext}`, `${dir}/base${ext}`, `${dir}/_reset${ext}`]
        : [`_base${ext}`, `base${ext}`]
    },
  },
]

export const cssStrategy: FileTypeStrategyConfig = {
  extensions: ['.css'],
  priorityPatterns: cssPriorityPatterns,
  queryPatterns: cssQueryPatterns,
  relatedFilePatterns: cssRelatedFilePatterns,
  priorityWeight: 1.5,
  searchTypeDefinitions: false,
  searchBaseClasses: false,
  searchImportedModules: false,
}

export const scssStrategy: FileTypeStrategyConfig = {
  extensions: ['.scss', '.sass'],
  priorityPatterns: scssPriorityPatterns,
  queryPatterns: scssQueryPatterns,
  relatedFilePatterns: cssRelatedFilePatterns,
  priorityWeight: 1.5,
  searchTypeDefinitions: false,
  searchBaseClasses: false,
  searchImportedModules: false,
}

// ============================================================================
// Generic Strategy (fallback)
// ============================================================================

export const genericStrategy: FileTypeStrategyConfig = {
  extensions: [],
  priorityPatterns: [],
  queryPatterns: [],
  relatedFilePatterns: [],
  priorityWeight: 1.0,
  searchTypeDefinitions: false,
  searchBaseClasses: false,
  searchImportedModules: false,
}

// ============================================================================
// Strategy Registry and Utilities
// ============================================================================

/**
 * Map of file type strategies by their identifier.
 */
export const FILE_TYPE_STRATEGIES: Record<FileTypeStrategy, FileTypeStrategyConfig> = {
  typescript: typescriptStrategy,
  javascript: javascriptStrategy,
  python: pythonStrategy,
  go: goStrategy,
  css: cssStrategy,
  scss: scssStrategy,
  rust: genericStrategy, // Can be expanded later
  java: genericStrategy, // Can be expanded later
  generic: genericStrategy,
}

/**
 * Get the file type from a filename.
 */
export function getFileType(filename: string): FileTypeStrategy {
  const ext = filename.slice(filename.lastIndexOf('.')).toLowerCase()

  for (const [type, config] of Object.entries(FILE_TYPE_STRATEGIES)) {
    if (config.extensions.includes(ext)) {
      return type as FileTypeStrategy
    }
  }

  return 'generic'
}

/**
 * Get the strategy configuration for a file.
 */
export function getStrategyForFile(filename: string): FileTypeStrategyConfig {
  const fileType = getFileType(filename)
  return FILE_TYPE_STRATEGIES[fileType]
}

/**
 * Extract priority queries from code using the strategy's priority patterns.
 */
export function extractPriorityQueries(
  code: string,
  strategy: FileTypeStrategyConfig
): { query: string; weight: number }[] {
  const results: { query: string; weight: number }[] = []

  for (const priorityPattern of strategy.priorityPatterns) {
    const regex = new RegExp(priorityPattern.pattern.source, priorityPattern.pattern.flags)
    const matches = code.matchAll(regex)

    for (const match of matches) {
      if (match[1]) {
        // Apply the query template with captured groups
        let query = priorityPattern.queryTemplate
        for (let i = 1; i < match.length; i++) {
          if (match[i]) {
            query = query.replace(`$${i}`, match[i].trim())
          }
        }

        // Clean up the query
        query = query.trim()
        if (query.length >= 3) {
          results.push({ query, weight: priorityPattern.weight })
        }
      }
    }
  }

  return results
}

/**
 * Extract queries using the strategy's query patterns.
 */
export function extractQueriesUsingStrategy(
  code: string,
  strategy: FileTypeStrategyConfig
): string[] {
  const queries: string[] = []

  for (const queryPattern of strategy.queryPatterns) {
    const regex = new RegExp(queryPattern.pattern.source, queryPattern.pattern.flags)
    const matches = code.matchAll(regex)

    for (const match of matches) {
      const captured = match[queryPattern.captureGroup]
      if (captured && captured.length >= 3) {
        queries.push(captured)
      }
    }
  }

  return [...new Set(queries)]
}

/**
 * Generate related file paths using the strategy's related file patterns.
 */
export function generateRelatedFilePaths(
  filename: string,
  strategy: FileTypeStrategyConfig
): string[] {
  const results: string[] = []

  for (const relatedPattern of strategy.relatedFilePatterns) {
    const paths = relatedPattern.transform(filename)
    results.push(...paths)
  }

  return [...new Set(results)]
}

/**
 * Apply file-type specific strategy to enhance context retrieval.
 *
 * This function:
 * 1. Extracts priority queries (type definitions, imports, etc.)
 * 2. Searches for related files (e.g., __init__.py, index.ts)
 * 3. Returns additional context based on the file type
 */
export async function applyFileTypeStrategy(
  modifiedFiles: string[],
  codeByFile: Map<string, string>,
  client: IndexerClient,
  repoUrl: string,
  branch?: string
): Promise<StrategyResult> {
  const additionalQueries: string[] = []
  const priorityChunkIds = new Set<string>()
  const relatedFilesSearched: string[] = []

  // Process each modified file
  for (const filename of modifiedFiles) {
    const strategy = getStrategyForFile(filename)

    if (strategy === genericStrategy) {
      continue // Skip generic files
    }

    logger.debug(`Applying ${getFileType(filename)} strategy to ${filename}`)

    const code = codeByFile.get(filename) || ''

    // Extract priority queries
    const priorityQueries = extractPriorityQueries(code, strategy)
    for (const { query } of priorityQueries) {
      if (!additionalQueries.includes(query)) {
        additionalQueries.push(query)
      }
    }

    // Extract additional queries using strategy patterns
    const strategyQueries = extractQueriesUsingStrategy(code, strategy)
    for (const query of strategyQueries) {
      if (!additionalQueries.includes(query)) {
        additionalQueries.push(query)
      }
    }

    // Generate and search for related files
    const relatedPaths = generateRelatedFilePaths(filename, strategy)
    for (const relatedPath of relatedPaths) {
      if (!relatedFilesSearched.includes(relatedPath)) {
        relatedFilesSearched.push(relatedPath)

        try {
          const results = await client.search(`file:${relatedPath}`, repoUrl, 2, branch)
          for (const chunk of results) {
            const id = `${chunk.filename}:${chunk.startLine}-${chunk.endLine}`
            priorityChunkIds.add(id)
          }
        } catch {
          // Ignore search errors for related files
        }
      }
    }
  }

  logger.debug(`File-type strategy generated ${additionalQueries.length} additional queries`)
  logger.debug(`File-type strategy searched ${relatedFilesSearched.length} related files`)

  return {
    additionalQueries,
    priorityChunkIds,
    relatedFilesSearched,
  }
}

/**
 * Apply priority weighting to chunks based on file-type strategy results.
 */
export function applyStrategyWeighting(
  chunks: WeightedCodeChunk[],
  strategyResult: StrategyResult,
  modifiedFiles: string[]
): WeightedCodeChunk[] {
  // Build a map of strategies by file for quick lookup
  const strategyByFile = new Map<string, FileTypeStrategyConfig>()
  for (const filename of modifiedFiles) {
    strategyByFile.set(filename, getStrategyForFile(filename))
  }

  return chunks.map(chunk => {
    const id = `${chunk.filename}:${chunk.startLine}-${chunk.endLine}`

    // Check if this chunk was found via related file search
    if (strategyResult.priorityChunkIds.has(id)) {
      const strategy = getStrategyForFile(chunk.filename)
      return {
        ...chunk,
        score: chunk.score * strategy.priorityWeight,
        weightMultiplier: chunk.weightMultiplier * strategy.priorityWeight,
      }
    }

    return chunk
  })
}

/**
 * User-configurable overrides for file-type strategies.
 */
export interface FileTypeStrategyOverrides {
  /** Override priority weight for specific file types */
  priorityWeights?: Partial<Record<FileTypeStrategy, number>>

  /** Disable specific strategies */
  disabledStrategies?: FileTypeStrategy[]

  /** Custom extension mappings */
  extensionMappings?: Record<string, FileTypeStrategy>
}

/**
 * Apply user configuration overrides to strategies.
 */
export function applyStrategyOverrides(overrides?: FileTypeStrategyOverrides): void {
  if (!overrides) return

  // Apply priority weight overrides
  if (overrides.priorityWeights) {
    for (const [type, weight] of Object.entries(overrides.priorityWeights)) {
      const strategy = FILE_TYPE_STRATEGIES[type as FileTypeStrategy]
      if (strategy && typeof weight === 'number') {
        strategy.priorityWeight = weight
      }
    }
  }

  // Apply extension mappings
  if (overrides.extensionMappings) {
    for (const [ext, type] of Object.entries(overrides.extensionMappings)) {
      const strategy = FILE_TYPE_STRATEGIES[type]
      if (strategy && !strategy.extensions.includes(ext)) {
        strategy.extensions.push(ext)
      }
    }
  }
}
